# Configuring a group of zones for Cascade
# ========================================
#
# A policy is a collection of settings that apply to a group of zones known to
# Cascade.  Policy controls how Cascade operates on those zones, e.g. how they
# are signed. This file is a template describing all possible settings and their
# defaults. You can copy this and customize it to your liking, or write a policy
# file from scratch using this as a reference.
# 
# Policy files are managed by the user, and are stored at a configurable path
# (by default, '/etc/cascade/policies').  You can add, modify, and remove
# policy files, then update Cascade with 'cascade policy reload'.  Note that:
#
# - Cascade maintains an internal copy of all policies, and will use this until
#   'cascade policy reload' is used.  If reloading fails, Cascade will continue
#   to use its existing internal copy.  It won't reload policies if it restarts.
# 
# - Policies cannot be removed if they are attached to zones; those zones need
#   to be deleted or shifted to a different policy first.  If you remove a used
#   policy and reload policies in Cascade, it will fail and continue to use its
#   internal copy of the policy.

# The policy file version.
#
# This is the only required option.  All other settings, and their defaults, are
# associated with this version number.  More versions may be added in the future
# and Cascade may drop support for older versions over time.
#
# - 'v1': This format.
version = "v1"


# How zones are loaded.
[loader]

# How loaded zones are reviewed.
#
# Review offers an opportunity to perform external checks on the zone contents
# loaded by Cascade.
[loader.review]

# Whether review is required.
#
# If this is 'true', a loaded version of a zone will not be signed or published
# until it is approved.  If it is 'false', loaded zones will be signed
# immediately.  At the moment, the review hook will only be run if this is set
# to true.
required = false

# A hook for reviewing a loaded zone.
#
# This command string will be executed in the user's shell when a new version of
# a zone is loaded.  At the moment, it will only be run if 'required' is true.
#
# It will receive the following information via environment variables:
#
# - 'CASCADE_ZONE': The name of the zone, formatted without a trailing dot.
# - 'CASCADE_SERIAL': The serial number of the zone (decimal integer).
# - 'CASCADE_SERVER': The TCP/UDP port where Cascade is serving the zone for
#     review, formatted '<ip-addr>:<port>'.
#     TODO: Multiple such servers can be configured, which one should we pick?
#
# The command will be called from an unspecified directory, and it must be
# accessible to Cascade (i.e. after it has dropped privileges).  Its exit code
# will determine whether the zone is approved or not.
#cmd-hook = "review-unsigned-zone.sh"


# DNSSEC key management.
[key-manager]

# How long keys are considered valid for.
#
# If a key has been used for longer than this time, it is considered expired,
# and (if enabled) it will automatically be rolled over to a new key.  Even
# if automatic rollovers are not enabled, the key will be reported as expired.
# This is a soft condition -- DNSSEC does not have a concept of key expiry,
# and it will not break DNSSEC validation, but it is usually important to the
# security of the zone.
#
# Independent validity times are set for KSKs, ZSKs, and CSKs.  An integer
# value will be interpreted as seconds; 'forever' means keys never expire.
ksk.validity = "31536000" # TODO: "1Y"
zsk.validity = "2592000" # TODO: "1M"
csk.validity = "31536000"

# Whether to automatically start key rollovers.
#
# If this is enabled, Cascade will automatically start rolling over keys when
# they expire (as per 'validity').  When using this setting, 'validity' must not
# be set to 'forever'.
#
# The first step in a rollover will be to generate new keys to replace old ones.
# By disabling this setting, the user can manually control how new keys are
# generated, and when rollovers happen.
#
# TODO: Maybe we want to start rolling over keys some time before expiry?
ksk.auto-start = true
zsk.auto-start = true
csk.auto-start = true
alg.auto-start = true

# Whether to automatically check for record propagation.
#
# If this is enabled, Cascade will automatically contact public DNS servers to
# detect when new records (e.g. DNSKEY) are visible globally.  It is necessary
# to wait until some records are visible globally to progress key rollovers.  If
# this is disabled, the user will have to inform Cascade when these conditions
# are reached manually.
#
# For this setting to work, Cascade must have network access to the zone's
# public nameservers and the parent zone's public nameservers.
ksk.auto-report = true
zsk.auto-report = true
csk.auto-report = true
alg.auto-report = true

# Whether to automatically wait for cache expiry.
#
# If this is enabled, Cascade will automatically progress through key rollover
# steps that need to wait for downstream users' DNS caches to expire.  It will
# estimate the right amount of time to wait based on record TTLs.
ksk.auto-expire = true
zsk.auto-expire = true
csk.auto-expire = true
alg.auto-expire = true

# Whether to automatically check for rollover completion.
#
# Like 'auto-report', if this setting is enabled, Cascade will automatically
# contact public DNS servers to detect when new records are visible globally.
# 'auto-done' specifically affects automatic checks for the last step of key
# rollovers, and is independent from 'auto-report'.
#
# For this setting to work, Cascade must have network access to the zone's
# public nameservers and the parent zone's public nameservers.
ksk.auto-done = true
zsk.auto-done = true
csk.auto-done = true
alg.auto-done = true

# The hash algorithm used by the parent zones' DS records.
#
# Supported options:
# - 'sha256': SHA-256.
# - 'sha384': SHA-384.
ds-algorithm = "sha256"

# Whether to automatically remove expired keys.
#
# If this is set, expired keys will be removed automatically (by deleting the
# files for on-disk keys or removing it from the HSM).
#
# TODO: Perhaps support removing keys after a certain delay?
auto-remove = true

# The management of DNS records by the key manager.
# 
# The key manager generates and signs several records (DNSKEY and CDS).  This
# section controls its behaviour towards them.
[key-manager.records]

# The TTL for the generated records.
#
# TODO: Perhaps Cascade can automatically set this to the SOA minimum.  The
#   key manager would have to be sent that information somehow.
ttl = 3600 # TODO: "1h"

# The offset for generated signature inceptions.
#
# Record signatures have a fixed inception time, from when they are considered
# valid.  An imprecise computer clock could cause signatures to be considered
# invalid, because their inception point appears to be some time in the future.
# To prevent such cases, this setting allows the inception time to be offset
# into the past.
#
# Independent offsets can be set for each type of record.  An integer value is
# intepreted as seconds; inception times will be calculated as 'now - offset'
# at the time of signing.
dnskey.signature-inception-offset = 86400 # TODO: "1d"
cds.signature-inception-offset = 86400

# The lifetime of generated signatures.
#
# Record signatures have a fixed lifetime, after which they are considered
# invalid.  To keep the zone valid, the signatures should be regenerated before
# they expire; see 'signature-remain-time' to control regeneration time.
#
# Independent lifetimes can be set for each type of record.  An integer value is
# interpreted as seconds.
dnskey.signature-lifetime = 1209600 # TODO: "2w"
cds.signature-lifetime = 1209600

# The amount of time remaining before expiry when signatures will be
# regenerated.
#
# In order to prevent a zone's signatures from appearing invalid, they
# have to be regenerated before they expire.  That hard limit is set by
# 'signature-lifetime' above.  This setting controls how long before expiry
# signatures will be regenerated; it must be less than the 'signature-lifetime'
# setting.
#
# Independent waiting times can be set for each type of record.  An integer
# value is interpreted as seconds.
dnskey.signature-remain-time = 604800 # TODO: "1w"
cds.signature-remain-time = 604800

# How keys are generated.
[key-manager.generation]

# The HSM server to use.
#
# If this is set, the named HSM server (which must be configured via 'cascade
# hsm add') will be used for generating new DNSSEC keys.
#
# TODO: Link to a guide for using HSMs with Cascade.
#hsm-server-id = "softhsm"

# Whether to generate CSKs, instead of separate ZSKs and KSKs.
#
# A CSK (Combined Signing Key) takes the role of both ZSK and KSK for a zone,
# unlike the standard practice of using separate keys for ZSK and KSK.  This
# setting does not affect how DNSSEC validation is performed, only procedures
# for key rollovers.
#
# If this is enabled, Cascade will generate CSKs for the associated zones.
#
# TODO: Does this affect anything more than generation?  Does it affect how
# existing keys are rolled over?
use-csk = false

# Parameters for the cryptographic key material.
#
# DNSSEC supports various cryptographic algorithms for signatures; one must be
# selected, and for some algorithms, additional parameters are also necessary.
# The same parameters will be applied to the ZSK and KSK.
#
# - 'rsa-sha256[:<bits>]', RSASHA256 (algorithm 8), with a public key size of
#   '<bits>' (default 2048) bits.
# - 'rsa-sha512[:<bits>]', RSASHA512 (algorithm 10), with a public key size of
#   '<bits>' (default 2048) bits.
# - 'ecdsa-p256-sha256', ECDSAP256SHA256 (algorithm 13).
# - 'ecdsa-p384-sha384', ECDSAP384SHA384 (algorithm 14).
# - 'ed25519', ED25519 (algorithm 15).
# - 'ed448', ED448 (algorithm 16).
#
# There are additional algorithms, but many are now considered insecure, and it
# is recommended or mandated to avoid them.  In addition, RSA keys smaller than
# 2048 bits are not recommended.
#
# NOTE: At the moment, only RSASHA256 and ECDSAP256SHA256 work with HSMs.  Other
#   algorithms cannot be used with HSMs, and will cause generation failures.
parameters = "ecdsa-p256-sha256"
#parameters = "rsa-sha512:4096"


# How zones are signed.
#
# Note that certain records (e.g. DNSKEY and CDS records at the apex of the
# zone) are signed by the key manager, rather than the zone signer; see the
# `[key-manager.records]` section for configuring the signing of those records.
[signer]

# How SOA serial numbers are generated for signed zones.
#
# Supported options:
# - 'keep': use the same serial number as the unsigned zone.
# - 'counter': increment the serial number every time.
# - 'unixtime': use the current Unix time, in seconds.
# - 'date-counter': format the number as '<YYYY><MM><DD><xx>' in decimal.
#     '<xx>' is a simple counter to allow up to 100 versions per day.
serial-policy = "date-counter"

# The offset for generated signature inceptions.
#
# Record signatures have a fixed inception time, from when they are considered
# valid.  An imprecise computer clock could cause signatures to be considered
# invalid, because their inception point appears to be some time in the future.
# To prevent such cases, this setting allows the inception time to be offset
# into the past.
#
# An integer value is interpreted as seconds; inception times will be calculated
# as 'now - offset' at the time of signing.
signature-inception-offset = 86400 # TODO: "1d"

# The lifetime of generated signatures.
#
# Record signatures have a fixed lifetime, after which they are considered
# invalid.  To keep the zone valid, the signatures should be regenerated before
# they expire; see 'signature-remain-time' to control regeneration time.
#
# An integer value is interpreted as seconds.
signature-lifetime = 1209600 # TODO: "2w"

# The amount of time remaining before expiry when signatures will be
# regenerated.
#
# In order to prevent a zone's signatures from appearing invalid, they
# have to be regenerated before they expire.  That hard limit is set by
# 'signature-lifetime' above.  This setting controls how long before expiry
# signatures will be regenerated; it must be less than the 'signature-lifetime'
# setting.
#
# An integer value is interpreted as seconds.
signature-remain-time = 604800 # TODO: "1w"

# How denial-of-existence records are generated.
[signer.denial]

# The type of denial-of-existence records to generate.
#
# Supported options:
# - 'nsec': Use NSEC records (RFC 4034).
# - 'nsec3': Use NSEC3 records (RFC 5155).
type = "nsec"

# Whether to skip NSEC3 records for unsigned delegations.
#
# This enables the NSEC3 Opt-Out flag, and skips delegations to unsigned zones
# when generating NSEC3 records.  This affects the security of the zone, so be
# careful if you wish to enable it.
#opt-out = false

# How signed zones are reviewed.
[signer.review]

# Whether review is required.
#
# If this is 'true', a signed version of a zone will not be published until it
# is approved.  If it is 'false', signed zones will be published immediately.
# At the moment, the review hook will only be run if this is set to true.
required = false

# A hook for reviewing a signed zone.
#
# This command string will be executed in the user's shell when a new version of
# a zone is signed.  At the moment, it will only be run if 'required' is true.
#
# It will receive the following information via environment variables:
#
# - 'CASCADE_ZONE': The name of the zone, formatted without a trailing dot.
# - 'CASCADE_SERIAL': The serial number of the signed zone (decimal integer).
# - 'CASCADE_SERVER': The TCP/UDP port where Cascade is serving the zone for
#   review, formatted '<ip-addr>:<port>'.
#     TODO: Multiple such servers can be configured, which one should we pick?
#
# The command will be called from an unspecified directory, and it must be
# accessible to Cascade (i.e. after it has dropped privileges).  Its exit code
# will determine whether the zone is approved or not.
#cmd-hook = "review-signed-zone.sh"


# How published zones are served.
[server.outbound]

# The set of nameservers to which NOTIFY messages should be sent.
#
# If empty, no NOTIFY messages will be sent.
# 
# A collection of IP:[port], defaulting to port 53 when not specified.
send-notify-to = []
