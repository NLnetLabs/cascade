# Configuring Nameshed
# ====================

# The configuration file version.
# - 'v1': This format.
version = "v1"

# Configuring the Nameshed daemon.
#
# This controls Nameshed's behaviour as a daemon, i.e. how it interacts with the
# external system.
[daemon]
#
# The minimum severity of the messages logged by the daemon.
#
# Messages at or above the specified severity level will be logged.  The
# following levels are defined:
# - 'trace': A function or variable was interacted with, for debugging.
# - 'debug': Something occurred that may be relevant to debugging.
# - 'info': Things are proceeding as expected.
# - 'warning': Something does not appear to be correct.
# - 'error': Something went wrong (but Nameshed can recover).
# - 'critical': Something went wrong and Nameshed can't function at all.
log-level = "info"
#
# The location the daemon writes logs to.
#
# Logs are appended line-by-line to the specified file path.  It can be set to
# '/dev/stdout' or '/dev/stderr' for standard output and error, respectively.
# If it is a terminal, ANSI escape codes may be used to style the output.
log-file = "/dev/stdout"

# Configuring how zones are loaded.
[loader]
# Where to listen for zone update notifications.
#
# A DNS server will be bound to these addresses.  If a DNS NOTIFY message for a
# known zone is received there, the zone will be reloaded appropriately.
#
# Unless explicitly specified (e.g. 'udp://localhost:0000'), each address will
# be served over UDP and TCP.  An empty array will disable listening entirely.
notif-listeners = ["127.0.0.1:8050"] # TODO: Pick a good default port

# Configuring whether and how loaded zones are reviewed.
[loader.review]
# Where to serve loaded zones for review.
#
# A DNS server will be bound to these addresses, and will serve the contents of
# all loaded zones.  This can be used to verify the consistency of these zones.
#
# Unless explicitly specified (e.g. 'udp://localhost:0000'), each address will
# be served over UDP and TCP.  An empty array will disable serving entirely.
servers = ["127.0.0.1:8051"] # TODO: Pick a good default port

# Configuring how zones are signed.
[signer]

# Configuring whether and how signed zones are reviewed
[signer.review]
# Where to serve signed zones for review.
#
# A DNS server will be bound to these addresses, and will serve the contents of
# all signed zones.  This can be used to check the correctness of the signer.
#
# Unless explicitly specified (e.g. 'udp://localhost:0000'), each address will
# be served over UDP and TCP.  An empty array will disable serving entirely.
servers = ["127.0.0.1:8052"] # TODO: Pick a good default port.

# Configuring DNSSEC key management.
[key-manager]

# Configuring how zones are published.
[server]
# Where to serve published zones.
# 
# A DNS server will be bound to these addresses, and will serve the contents of
# all published zones.  This is the final output from Nameshed.
#
# Unless explicitly specified (e.g. 'udp://localhost:0000'), each address will
# be served over UDP and TCP.  At least one address must be specified.
servers = ["127.0.0.1:8053"] # TODO: Pick a good default port.

# Configuring cryptography.
[crypto]

# Configuring an HSM store.
[crypto.hsm-store.softhsm]
# The type of the HSM store.
#
# At the moment, only KMIP is supported.  To use HSMs via PKCS#11, launch a
# 'nameshed-hsm-relay' [1] instance and connect to it over KMIP.
#
# [1]: https://github.com/NLnetLabs/nameshed-hsm-relay
type = "kmip"
#
# The address of the HSM store.
#
# This specifies a TLS/TCP port to connect to, in '<hostname>:<port>' format.
# If a port is not specified, 5696 will be used.
address = "localhost:21467"
#
# How Nameshed should authenticate itself to the HSM.
#
# This specifies the TLS client certificates to use, if any.
authentication.type = "none"
#
# How Nameshed should verify the identity of the HSM.
#
# This specifies the TLS certificates (or other verification path) the HSM is
# expected to present.
verification.type = "none"
#
# The KMIP credentials Nameshed should use during signing.
#
# These credentials will be passed over KMIP, and their semantics is defined by
# the underlying HSM.  Check the HSM-specific documentation.
credentials = { username = "foo", password = "1234" }

