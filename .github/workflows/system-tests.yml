# README:
#
# TL;DR:
#   - Docker: `act --network default -W .github/workflows/system-tests.yml --job your-test`
#   - Podman: `act --network podman -W .github/workflows/system-tests.yml --job your-test`
#   Optionally start a standalone artifact server to deduplicate compilation between tests (see below).
#
# This action is primarily for use with https://github.com/nektos/act and has
# been tested using the full image (catthehacker/ubuntu:full-latest).
#
# **Building from source (once or always)**
#
# The build job builds the project and uploads the target directory as an
# artifact for use by the other jobs to deduplicate the compilation step. If
# fetching the pre-built fails, it will just build them from source. So this
# workflow is still usable without an artifact server.
#
# **Network requirement (why --network default)**
#
# In the test environment, Unbound needs to bind to localhost:53, which is not
# possible with the default network (act uses host networking by default).
# localhost:53 is already in use by your system's stub resolver (probably
# systemd-resolved). Therefore, you need to specify a different network to use:
# `act --network default` on Docker, or `act --network podman` on Podman.
#
# **Standalone artifact server for use with --network**
#
# In a non-host network, act cannot access its own artifact server (that would
# be started using the `--artifact-server-path` option). Therefore Jannik has
# hacked together a standalone artifact server binary that uses the existing
# act artifact server code (https://github.com/mozzieongit/act).
# You can run that server in a separate container on the same network (see the
# README of https://github.com/mozzieongit/act) and then have act use that
# artifact server.
#
# **Running single jobs/tests**
#
# You can run single jobs with act using the `--job` option. However, if the
# job sets the `needs` option, that job will always be run before. If you want
# to test/debug your test without always re-building the source, you could
# comment out the `needs` option, build once using `act ... --job build` and
# then use `act ... --job your-test` to only run your test. If there is no
# artifact server available, the code will still always be built from source.
#
# **Example test job**
#
# ```yml
#   job-name:
#     name: Run tests with resolvers/namerservers
#     runs-on: ${{ matrix.os }}
#     needs: build
#     strategy:
#       matrix:
#         os: [ubuntu-latest]
#         rust: [stable] # see build job
#     steps:
#     - name: Checkout repository
#       uses: actions/checkout@v4
#     - name: Prepare the system test environment
#       uses: ./.github/actions/prepare-systest-env
#       with:
#         artifact-name: ${{ format('cascade_{0}_{1}_{2}', github.sha, matrix.os, matrix.rust) }}
#     # - name: Only download/build the binaries without setting up the test environment
#     #   uses: ./.github/actions/download-or-build
#     #   with:
#     #     artifact-name: ${{ format('cascade_{0}_{1}_{2}', github.sha, matrix.os, matrix.rust) }}
#     - run: target/debug/cascade --version
#     ### RUN YOUR TESTS HERE
#     # # Optional, the container gets cleaned up anyway (at least in act)
#     # - name: Stop the setup
#     #   run: scripts/manage-test-environment.sh stop
# ```

name: System/Integration tests
on:
  # Triggering on PRs and arbitrary branch pushes is not enabled because most
  # of the time this expensive test suite should not be run. Using this
  # trigger allows explicitly running this test suite on a selected branch.
  workflow_dispatch:

env:
  # Set this assignment to your choosing to set the cargo build verbosity
  CARGO_TERM_VERBOSE: ${{ github.actor != 'nektos/act' }}
  # CARGO_TERM_VERBOSE: true


jobs:
  build:
    # First build the project for once for all systems to deduplicate work
    # in the later tests
    name: Build the project for use by the later tests
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        os: [ubuntu-latest]
        rust: [stable]
        # the  hecrj/setup-rust-action@v2 action seems broken in act, therefore
        # only using stable rust, which is installed in the runner image
        # rust: [1.84.0, stable, beta, nightly]
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
    - run: cargo build ${{ matrix.args }}
    - name: Tar built binaries to preserve permissions
      run: tar -cf target.tar target
    - name: Upload built binaries
      # To allow running the workflow without an artifact server an error here
      # should not fail the workflow.
      continue-on-error: true
      uses: actions/upload-artifact@v4
      with:
        name: ${{ format('cascade_{0}_{1}_{2}', github.sha, matrix.os, matrix.rust) }}
        # A file, directory or wildcard pattern that describes what to upload. Required.
        path: target.tar
        # The level of compression for Zlib to be applied to the artifact archive.
        # The value can range from 0 to 9.
        # For large files that are not easily compressed, a value of 0 is recommended for significantly faster uploads.
        # Optional. Default is '6'
        compression-level: 1

  test:
    name: Run tests with resolvers/namerservers
    runs-on: ${{ matrix.os }}
    needs: build

    strategy:
      matrix:
        os: [ubuntu-latest]
        rust: [stable] # see build job
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
    - name: Prepare the system test environment
      uses: ./.github/actions/prepare-systest-env
      with:
        artifact-name: ${{ format('cascade_{0}_{1}_{2}', github.sha, matrix.os, matrix.rust) }}
    - run: target/debug/cascade --version
    # # Optional, the container gets cleaned up anyway (at least in act)
    # - name: Stop the setup
    #   run: scripts/manage-test-environment.sh stop
